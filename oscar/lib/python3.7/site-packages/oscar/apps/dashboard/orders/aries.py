import json
from lib2to3.pgen2 import token
import threading
import subprocess
import time
from django.db import connection
import requests
import os.path
from django.conf import settings
import datetime


host = settings.REST_ARIES['HOST']
port = settings.REST_ARIES['PORT']
wallet_prefix = settings.REST_ARIES['WALLET_PREFIX']
wallet_webhook_urls = settings.REST_ARIES['WALLET_WEBHOOK_URLS']
wallet_pass = settings.REST_ARIES['WALLET_PASS']
serviceEndpoint = settings.REST_ARIES['SERVICEENDPOINT']
endpoint = host + ":" + port
issuer = settings.BADGR['ISSUER']
badge_class = settings.BADGR['BADGE_CLASS']
user_badgr = settings.BADGR['USER']
pass_badgr = settings.BADGR['PASSWORD']
endpoint_badgr = settings.BADGR['HOST'] + ":" + settings.BADGR['PORT']

   

def check_connection(email, token):
    #   This function create invitation in Hyperledger Aries between to connect users

    header = {'Authorization': 'Bearer ' + token}
    
    did = None
    connection = None
    
    try:
        response = requests.get(
            endpoint
            + "/connections?alias=" + email,
            headers=header
        )
        response.raise_for_status()
        connection = response.json()

    except:
        raise
    finally:
        return connection
   

def get_wallet_id(email_user):
    #Check if subwallet in Hyperledger Aries exist         
    connection = None
    did = None
    
    try:
        response = requests.get(
            endpoint
            + "/multitenancy/wallets?wallet_name=" + wallet_prefix + "." + email_user,
        )
        response.raise_for_status()
        connection = response.json()
        did = connection["results"][0]["wallet_id"]
                        
    except:
        raise    
    finally:    
        return did

def get_token_aries(wallet_id):
    #Check if subwallet in Hyperledger Aries exist        
    value = None   
    connection = None
    token = None
    
    try:
        response = requests.post(
            endpoint
            + "/multitenancy/wallet/" + wallet_id + "/token",
        )
        response.raise_for_status()
        connection = response.json()
        token = connection["token"]
                        
    except:
        raise    
    finally:    
        return token
    
def send_credential(email_user, order):
    #   This function send credential to Hyperledger Aries
    did_issuer = None
    connection_id = None 
    
    now = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).isoformat()
    connection = None
    wallet_id_ecommerce = get_wallet_id(settings.REST_ARIES['EMAIL_ECOMMERCE'])
    token_ecommerce = str(get_token_aries(wallet_id_ecommerce))
    did_issuer = settings.REST_ARIES['DID']
    connection = check_connection(email_user, token_ecommerce)
    connection_id = connection['results'][0]['connection_id']
    header = {'Authorization': 'Bearer ' + token_ecommerce, 'accept': 'application/json', 'Content-Type': 'application/json'}
           
    json_model = {
        "connection_id":connection_id,
        "filter":{
        "ld_proof":{
	    "options":{
            "proofType":"BbsBlsSignature2020"
        },
	    "credential": {
               "@context": [
                  "https://www.w3.org/2018/credentials/v1",
                #   "https://w3id.org/security/bbs/v1",
                  {  
					"order": "d1:order"
                }
               ],
               "type": ["VerifiableCredential", "AATHDriversLicense"],
                "issuer": did_issuer,
                "issuanceDate": now,
                "credentialSubject": {"order": order}
            }	
			}
	 } 
    }
    
   
      
    try:
        response = requests.post(
            endpoint
            + "/issue-credential-2.0/send-offer",
            json.dumps(json_model),
            headers=header
        )
        
        response.raise_for_status()
        connection = response.json()
                    
    except:
        raise    
    finally:             
        return response

def clean_exchange_records(email):
    wallet_id = get_wallet_id(email)
    token_id = str(get_token_aries(wallet_id))
    
    header = {'Authorization': 'Bearer ' + token_id, 'accept': 'application/json', 'Content-Type': 'application/ld+json'}
    
    try:
        response = requests.get(
            endpoint
            + "/issue-credential-2.0/records",
            headers=header
        )

        response.raise_for_status()
        connection = response.json()

        i = 0

        for conn in connection['results']:
            cred_ex_id=connection['results'][i]['cred_ex_record']['cred_ex_id']
            remove_record(cred_ex_id, token_id)
            i+=1
    except:
        raise
    finally:
        return cred_ex_id

def remove_record(cred_ex_id, token_id):

    
    header = {'Authorization': 'Bearer ' + token_id, 'accept': 'application/json', 'Content-Type': 'application/ld+json'}
    
    try:
        response = requests.delete(
            endpoint
            + "/issue-credential-2.0/records/" + cred_ex_id,
            headers=header
        )

        response.raise_for_status()
        connection = response.json()

    except:
        raise
    finally:
        return connection