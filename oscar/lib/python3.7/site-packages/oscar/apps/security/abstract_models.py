from decimal import Decimal

from django.core import exceptions
from django.db import models
from django.db.models import Sum
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from oscar.core.compat import AUTH_USER_MODEL
from oscar.core.decorators import deprecated


class AbstractSecuritySet(models.Model):
    name = models.CharField(verbose_name=_('Name'), max_length=100, unique=True)
    count = models.PositiveIntegerField(verbose_name=_('Number of security'))
    code_length = models.IntegerField(
        verbose_name=_('Length of Code'), default=12)
    description = models.TextField(verbose_name=_('Description'))
    date_created = models.DateTimeField(auto_now_add=True, db_index=True)
    start_datetime = models.DateTimeField(_('Start datetime'))
    end_datetime = models.DateTimeField(_('End datetime'))

    class Meta:
        abstract = True
        app_label = 'security'
        get_latest_by = 'date_created'
        ordering = ['-date_created']
        verbose_name = _("SecuritySet")
        verbose_name_plural = _("SecuritySets")

    def __str__(self):
        return self.name

    def clean(self):
        if self.start_datetime and self.end_datetime and (self.start_datetime > self.end_datetime):
            raise exceptions.ValidationError(_('End date should be later than start date'))

    def update_count(self):
        securitys_count = self.Securitys.count()
        if self.count != securitys_count:
            self.count = securitys_count
            self.save()

    def is_active(self, test_datetime=None):
        test_datetime = test_datetime or timezone.now()
        return self.start_datetime <= test_datetime <= self.end_datetime

    @property
    def num_basket_additions(self):
        value = self.securitys.aggregate(result=Sum('num_basket_additions'))
        return value['result']

    @property
    def num_orders(self):
        value = self.securitys.aggregate(result=Sum('num_orders'))
        return value['result']

    @property
    def total_discount(self):
        value = self.securitys.aggregate(result=Sum('total_discount'))
        return value['result']


class AbstractSecurity(models.Model):
    name = models.CharField(_("Name"), max_length=128, unique=True,
                            help_text=_("This will be shown in the checkout"
                                        " and basket once the security is"
                                        " entered"))
    code = models.CharField(_("Code"), max_length=128, db_index=True,
                            unique=True, help_text=_("Case insensitive / No"
                                                     " spaces allowed"))
    offers = models.ManyToManyField(
        'offer.ConditionalOffer', related_name='securitys',
        verbose_name=_("Offers"), limit_choices_to={'offer_type': "Security"})

    SINGLE_USE, MULTI_USE, ONCE_PER_CUSTOMER = (
        'Single use', 'Multi-use', 'Once per customer')
    USAGE_CHOICES = (
        (SINGLE_USE, _("Can be used once by one customer")),
        (MULTI_USE, _("Can be used multiple times by multiple customers")),
        (ONCE_PER_CUSTOMER, _("Can only be used once per customer")),
    )
    usage = models.CharField(_("Usage"), max_length=128,
                             choices=USAGE_CHOICES, default=MULTI_USE)

    start_datetime = models.DateTimeField(_('Start datetime'), db_index=True)
    end_datetime = models.DateTimeField(_('End datetime'), db_index=True)

    # Reporting information. Not used to enforce any consumption limits.
    num_basket_additions = models.PositiveIntegerField(
        _("Times added to basket"), default=0)
    num_orders = models.PositiveIntegerField(_("Times on orders"), default=0)
    total_discount = models.DecimalField(
        _("Total discount"), decimal_places=2, max_digits=12,
        default=Decimal('0.00'))

    security_set = models.ForeignKey(
        'security.SecuritySet', null=True, blank=True, related_name='securitys',
        on_delete=models.CASCADE
    )

    date_created = models.DateTimeField(auto_now_add=True, db_index=True)

    class Meta:
        abstract = True
        app_label = 'security'
        ordering = ['-date_created']
        get_latest_by = 'date_created'
        verbose_name = _("Securitys")
        verbose_name_plural = _("Securitys")

    def __str__(self):
        return self.name

    def clean(self):
        if self.start_datetime and self.end_datetime and (self.start_datetime > self.end_datetime):
            raise exceptions.ValidationError(
                _('End date should be later than start date'))

    def save(self, *args, **kwargs):
        self.code = self.code.upper()
        super().save(*args, **kwargs)

    def is_active(self, test_datetime=None):
        test_datetime = test_datetime or timezone.now()
        return self.start_datetime <= test_datetime <= self.end_datetime

    def is_expired(self):
        now = timezone.now()
        return self.end_datetime < now

    def is_available_to_user(self, user=None):
        is_available, message = False, ''
        if self.usage == self.SINGLE_USE:
            is_available = not self.applications.exists()
            if not is_available:
                message = _("This security has already been used")
        elif self.usage == self.MULTI_USE:
            is_available = True
        elif self.usage == self.ONCE_PER_CUSTOMER:
            if not user.is_authenticated:
                is_available = False
                message = _(
                    "This securitys is only available to signed in users")
            else:
                is_available = not self.applications.filter(
                    security=self, user=user).exists()
                if not is_available:
                    message = _("You have already used this security in "
                                "a previous order")
        return is_available, message

    def is_available_for_basket(self, basket):
        is_available, message = self.is_available_to_user(user=basket.owner)
        if not is_available:
            return False, message

        is_available, message = False, _("This security is not available for this basket")
        for offer in self.offers.all():
            if offer.is_condition_satisfied(basket=basket):
                is_available = True
                message = ''
                break
        return is_available, message

    def record_usage(self, order, user):
        if user.is_authenticated:
            self.applications.create(security=self, order=order, user=user)
        else:
            self.applications.create(security=self, order=order)
        self.num_orders += 1
        self.save()
    record_usage.alters_data = True

    def record_discount(self, discount):
        """
        Record a discount that this offer has given
        """
        self.total_discount += discount['discount']
        self.save()
    record_discount.alters_data = True

    @property
    @deprecated
    def benefit(self):
        return self.offers.first().benefit


class AbstractSecurityApplication(models.Model):
    security = models.ForeignKey(
        'security.Security',
        on_delete=models.CASCADE,
        related_name="applications",
        verbose_name=_("Security"))


    user = models.ForeignKey(
        AUTH_USER_MODEL,
        blank=True,
        null=True,
        on_delete=models.CASCADE,
        verbose_name=_("User"))
    order = models.ForeignKey(
        'order.Order',
        on_delete=models.CASCADE,
        verbose_name=_("Order"))
    date_created = models.DateTimeField(auto_now_add=True, db_index=True)

    class Meta:
        abstract = True
        app_label = 'security'
        ordering = ['-date_created']
        verbose_name = _("Security Application")
        verbose_name_plural = _("Security Applications")

    def __str__(self):
        return _("'%(security)s' used by '%(user)s'") % {
            'security': self.security,
            'user': self.user}
